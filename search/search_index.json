{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Parallel Processing Systems (Labs)","text":""},{"location":"#course-summary","title":"Course summary","text":"<ul> <li> <p>This course focuses on the efficient use of modern parallel systems ranging from multi-core processors and many-core accelerators to large-scale distributed memory clusters. </p> </li> <li> <p>The course puts equal emphasis on the theoretical foundations of parallel computing, and on practical aspects of different parallel programming models.  It begins with a survey of common parallel architectures and types of parallelism, and then follows with an overview of formal approaches to assessing scalability and efficiency of parallel algorithms and their implementations. </p> </li> <li> <p>In the second part, the course covers the most common and current parallel programming techniques and APIs, including for shared address space, many-core accelerators, and distributed memory clusters. Each component of the course involves solving practical computational and data driven problems, such as basic algorithms like sorting or searching and numerical data analysis problems.</p> </li> </ul>"},{"location":"#lab-resources","title":"Lab Resources","text":"<p>It is quite important to try all examples in the lecture notes. You have two options:</p> <ol> <li> <p>Use online compilers (Quick and easy):</p> <ul> <li>Online GDB</li> </ul> </li> <li> <p>Install C++ GNU toolchain.</p> <ul> <li>Install MinGW GNU C++ compiler (version &gt;= 9.2)</li> <li>Install VS Code Editor</li> </ul> </li> </ol>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>C203, C408</li> </ul>"},{"location":"#grading","title":"Grading","text":"Activity Weight Lab1 10%"},{"location":"#tentative-schedule","title":"Tentative Schedule","text":"Week # Lab # Topic Week 0 Lab 0 Installing C++ compiler Week 1 Lab 1"},{"location":"labs/lab01/","title":"Lab(1): Introduction","text":"<p>Lab Objectives:</p> <ol> <li>Write your first parallel program using Pthread Library</li> <li>Learn how to create a thread to execute a job</li> <li>Learn how to measure the execution time </li> </ol> <p>Lab assignment:</p> <ol> <li>Do exercise 1, 2 and 3</li> <li> <p>For exercises 1 and 3: do the following:</p> <ul> <li>Write your name and index in the first line of your code</li> <li>take a screenshot(or more) of the code including your name and your index.</li> <li>Put all your work in a word document, and upload this document to LMS</li> </ul> </li> </ol>"},{"location":"labs/lab01/#fibonacci-series","title":"Fibonacci Series","text":"<p>Let us assume the following fibonacci series:</p> \\[ 1, 1, 2, 3, 5, 8, \\dots \\] <p>This series can be defined mathematically as follows:</p> \\[     fib(n) =  \\begin{cases}     1 &amp; n \\leq 1 \\\\     fib(n-1) + fib(n-2) &amp; n &gt; 1 \\end{cases} \\] <p>This implies that</p> <ol> <li>\\(fib(0) = 1\\)</li> <li>\\(fib(1) = 1\\)</li> <li>\\(fib(2) = fib(1) + fib(0) = 1 + 1 = 2\\)</li> <li>\\(fib(3) = fib(2) + fib(1) = 2 + 1 = 3\\)</li> <li>\\(fib(4) = fib(3) + fib(2) = 3 + 2 = 5\\)</li> <li>and so on.</li> </ol> <p>Let us implement the fibonacci series using a recursive function:</p> <pre><code>unsigned long long fib (unsigned int n)\n{\n    if (n &lt;= 1)\n        return 1;\n    else\n        return fib(n-1) + fib(n-2);\n}\n</code></pre> <p>The purpose of implementing fibonacci series recursively is that the running time is exponential. To see that, run the following program by clicking the button below:</p> <p><pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nunsigned long long fib(unsigned int);\n\nint main()\n{\n    cout &lt;&lt; \"fib(30) = \" &lt;&lt; fib(30) &lt;&lt; endl;\n    cout &lt;&lt; \"fib(40) = \" &lt;&lt; fib(40) &lt;&lt; endl;\n    cout &lt;&lt; \"fib(45) = \" &lt;&lt; fib(45) &lt;&lt; endl;\n    cout &lt;&lt; \"fib(48) = \" &lt;&lt; fib(48) &lt;&lt; endl;\n\n    return 0;\n}\n\nunsigned long long fib(unsigned int n)\n{\n    if (n &lt;= 1)\n        return 1;\n    else\n        return fib(n-1) + fib(n-2);\n}\n</code></pre> Jump to the code @ OnlineDBG</p> <p>If you run the code, you should observe that <code>fib(30)</code> will be promptly printed out. <code>fib(40)</code> may take half second to be printed. <code>fib(45)</code> will take 5-6 seconds. But <code>fib(48)</code> will take significant amount of time; almost 26 seconds. All these estimations are based on the CPU speed of my PC.</p>"},{"location":"labs/lab01/#the-execution-time","title":"The Execution Time","text":"<p>The execution time is the time taken by the system to execute a task. We can compute the execution time using the <code>std::chrono</code> library introduced in C++ 11. Here are the steps to compute the execution time:</p> <ol> <li> <p>Include the header file <code>chrono</code>: <pre><code>#include &lt;chrono&gt;\n</code></pre></p> </li> <li> <p>Set the clock to monotonic clock: <pre><code>using clock = std::chrono::steady_clock;\n</code></pre></p> </li> <li> <p>Get the starting time-point before executing the task: <pre><code>clock::time_point start = clock::now();\n</code></pre></p> </li> <li> <p>Get the ending time-point after executing the task: <pre><code>clock::time_point end = clock::now();\n</code></pre></p> </li> <li> <p>Compute the time duration: <pre><code>clock::duration execution_time = end - start;\n</code></pre></p> </li> <li> <p>Print out the duration time in (<code>seconds</code>, <code>milliseconds</code>, <code>microseconds</code>, etc): <pre><code>std::cout &lt;&lt; \"Execution time is \"\n          &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(execution_time).count() \n          &lt;&lt; \"ms.\" &lt;&lt; std::endl;\n</code></pre></p> </li> </ol> <p>Here is the complete program: <pre><code>#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n\nunsigned long long fib(unsigned int);\n\nint main()\n{\n    using clock = std::chrono::steady_clock;\n    clock::time_point start = clock::now();\n\n    // we need to know the execution time taken by fib(45)   \n    std::cout &lt;&lt; \"fib(45) = \" &lt;&lt; fib(45) &lt;&lt; std::endl;\n\n    clock::time_point end = clock::now();\n\n    clock::duration execution_time = end - start;\n    std::cout &lt;&lt; \"Execution time is \" \n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(execution_time).count() \n              &lt;&lt; \"ms.\" &lt;&lt; std::endl;\n}\n\nunsigned long long fib(unsigned int n)\n{\n    if (n &lt;= 1)\n        return 1;\n    else\n        return fib(n-1) + fib(n-2);\n}\n</code></pre></p>"},{"location":"labs/lab01/#printing-the-fibonacci-series","title":"Printing the Fibonacci series","text":"<p>Suppose that our problem is to print the fibonacci series from 0 up to 47. The following <code>for</code> loop will perform the task:</p> <p><pre><code>for (int n=0; n&lt;48; n++)\n    cout &lt;&lt; \"fib(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; endl;\n</code></pre> See the code @ OnlineGBD</p> <p>According to my PC, the execution time was almost 40 seconds.</p> <p>Exercise (1)</p> <p>Modify the above program to print out the execution time.</p>"},{"location":"labs/lab01/#parallelize-the-fibonacci-series","title":"Parallelize the Fibonacci series","text":"<p>In this lab, we are going to parallelize a serial program using POSIX pthread. To read more about POSIX pthread, visit LLNL High Performance Computing (HPC) or visit https://randu.org/tutorials/threads/.</p> <p>To create a thread:</p> <ol> <li>You need to put the task in a function.</li> <li> <p>The API to create a thread is <code>pthread_create()</code>. This function needs 4 arguments:</p> <ol> <li>When a thread is created, the API function returns (as argument) the thread handler (thread identifier). The data type of thread handler is <code>pthread_t</code>.</li> <li>Thread attributes to apply to the created thread. For the purpose of this course, you pass only <code>NULL</code>, which means the default attributes.</li> <li>The function/task to be executed by the created thread.</li> <li>The argument to be passed to the above function.</li> </ol> </li> </ol>"},{"location":"labs/lab01/#step-1-define-your-task-as-a-function","title":"STEP (1): Define your task as a function","text":"<p>We need to modify our serial program by defining a new function to compute the fibonacci series:</p> <p><pre><code>void computeFib()\n{\n    for (int n = 0; n &lt; 48; n += 1)\n        cout &lt;&lt; \"fib(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; endl;\n}\n</code></pre> Now our goal is create multiple processors (threads) to execute the above function. However, each processor should execute a sub-domain out of the domain\\([0, 48)\\).</p>"},{"location":"labs/lab01/#step-2-computation-decomposition","title":"STEP (2): Computation decomposition","text":"<p>Let us do computation decompsition according to the lecture (Listen to the lecture before proceeding):</p> <p><pre><code>void computeFib(int id)\n{\n    int block_length = N / NP; // divide N to NP processors\n    int start = id * block_length;\n    int end = start + block_length;\n\n    for (int n = start; n &lt; end; n += 1)\n        cout &lt;&lt; \"fib(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; endl;\n}\n</code></pre> where</p> <ul> <li><code>N</code> is a constant identifier that represents the value <code>48</code>.</li> <li><code>NP</code> is a constant identifier that represents the number of processors.</li> </ul> <p>Now, let us write the whole program serially, i.e., without creating processors (or threads): <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nunsigned long long fib(unsigned int);\nvoid computeFib(int);\n\nconst int N = 16;   // data size\nconst int NP = 4;   // number of processors\n\nint main()\n{\n    computeFib(0);  // this will be the task for P0\n    computeFib(1);  // this will be the task for P1\n    computeFib(2);  // this will be the task for P2\n    computeFib(3);  // this will be the task for P3\n\n    return 0;\n}\n\nvoid computeFib(int id)\n{\n    cout &lt;&lt; \"Processor (\" &lt;&lt; id &lt;&lt; \") started ...\" &lt;&lt; endl;\n    int block_length = N / NP; // divide N to NP processors\n    int start = id * block_length;\n    int end = start + block_length;\n\n    for (int n = start; n &lt; end; n += 1)\n        cout &lt;&lt; \"fib(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; endl;\n    cout &lt;&lt; \"Processor (\" &lt;&lt; id &lt;&lt; \") finished.\" &lt;&lt; endl;\n}\n\nunsigned long long fib(unsigned int n)\n{\n    if (n &lt;= 1)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n</code></pre></p> <p>Remarks</p> <ul> <li>Remember the above program is still a serial program. But it can easily be converted to parallel program by adding <code>pthread_create()</code>.</li> <li>The program will compute the fibonacci series from 0 up to 15</li> <li>Run the program @ OnlineGDB. It should be executed very quickly.</li> <li> <p>We divided the range from 0 up to 15 into 4 jobs:</p> <ol> <li>Job 1: <code>computeFib(0)</code> (should be assigned to processor 0)</li> <li>Job 2: <code>computeFib(1)</code> (should be assigned to processor 1)</li> <li>Job 3: <code>computeFib(2)</code> (should be assigned to processor 2)</li> <li>Job 4: <code>computeFib(3)</code> (should be assigned to processor 3)</li> </ol> </li> <li> <p>The argument in <code>computeFib()</code> should be the processor ID.</p> </li> <li>Observe the range of values to be computed for each processor/thread. </li> <li> <p>The details of the ranges is summarized in the following table:</p> Processors Ranges P0 0 1 2 3 P1 4 5 6 7 P2 8 9 10 11 P3 12 13 14 15 <p>Processor P0 will compute the fibonacci of 0, 1, 2 and 3. Processor P1 will compute the fibonacci of 4, 5, 6 and 7, and so on.</p> </li> </ul>"},{"location":"labs/lab01/#step-3-create-a-thread-for-each-job","title":"STEP (3): Create a thread for each job","text":"<p>Now, we need to run the four jobs in parallel using threads. In total, the program needs 4 threads. The <code>main()</code> function is modified as follows:</p> <pre><code>#include &lt;pthread&gt;\n.\n.\nint main()\n{\n    pthread_t t0, t1, t2, t3;  // four threads\n\n    // create a thread --&gt; computeFib(0)\n    pthread_create(&amp;t0, NULL, computeFib, 0);\n\n    // create a thread --&gt; computeFib(1)\n    pthread_create(&amp;t1, NULL, computeFib, 1);\n\n    // create a thread --&gt; computeFib(2)\n    pthread_create(&amp;t2, NULL, computeFib, 2);\n\n    // create a thread --&gt; computeFib(3)\n    pthread_create(&amp;t3, NULL, computeFib, 3);\n\n    // now wait for all threads to finish\n    pthread_join(t0, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    pthread_join(t3, NULL);\n\n    return 0;\n}\n</code></pre> <p>C++ may emit an error message if you try to compile the above code. This is due to type mismatch. We fixed this issue in the next step.</p>"},{"location":"labs/lab01/#step-4-the-parallel-program","title":"STEP (4): The Parallel Program","text":"<p>Here is the parallel program: <pre><code>#include &lt;iostream&gt;\n#include &lt;pthread.h&gt;\n\nusing namespace std;\n\nconst int N = 16;   // data size\nconst int NP = 4;   // number of processors\n\nunsigned long long fib (unsigned int);\nvoid computeFib (int);\n\nint main()\n{\n    pthread_t t0, t1, t2, t3;\n\n    pthread_create(&amp;t0, NULL, (void *(*)(void *))computeFib, (void *)0);\n    pthread_create(&amp;t1, NULL, (void *(*)(void *))computeFib, (void *)1);\n    pthread_create(&amp;t2, NULL, (void *(*)(void *))computeFib, (void *)2);\n    pthread_create(&amp;t3, NULL, (void *(*)(void *))computeFib, (void *)3);\n\n    pthread_join(t0, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    pthread_join(t3, NULL);\n\n    return 0;\n}\n\nvoid computeFib(int id)\n{\n    cout &lt;&lt; \"Processor (\" &lt;&lt; id &lt;&lt; \") started ...\" &lt;&lt; endl;\n    int block_length = N / NP; // divide N to NP processors\n    int start = id * block_length;\n    int end = start + block_length;\n\n    for (int n = start; n &lt; end; n += 1)\n        cout &lt;&lt; \"fib(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; endl;\n\n    cout &lt;&lt; \"Processor (\" &lt;&lt; id &lt;&lt; \") finished.\" &lt;&lt; endl;\n}\n\nunsigned long long fib(unsigned int n)\n{\n    if (n &lt;= 1)\n        return 1;\n    else\n        return fib(n-1) + fib(n-2);\n}\n</code></pre></p> <p>Exercise (2)</p> <p>Goto OnlineGDB by clicking the following button:</p> <p>Exercise</p> <p>Run this program FIVE time. In each run, take a screenshot and comment on the output. Your comment should not exceed more than THREE lines.</p> <p>Exercise (3)</p> <p>Modify the code in Exercise (2) by displaying the execution time. Be careful, the execution time is the time to execute ALL jobs.</p>"}]}