{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Parallel Processing Systems (Labs)","text":""},{"location":"#course-summary","title":"Course summary","text":"<ul> <li> <p>This course focuses on the efficient use of modern parallel systems ranging from multi-core processors and many-core accelerators to large-scale distributed memory clusters. </p> </li> <li> <p>The course puts equal emphasis on the theoretical foundations of parallel computing, and on practical aspects of different parallel programming models.  It begins with a survey of common parallel architectures and types of parallelism, and then follows with an overview of formal approaches to assessing scalability and efficiency of parallel algorithms and their implementations. </p> </li> <li> <p>In the second part, the course covers the most common and current parallel programming techniques and APIs, including for shared address space, many-core accelerators, and distributed memory clusters. Each component of the course involves solving practical computational and data driven problems, such as basic algorithms like sorting or searching and numerical data analysis problems.</p> </li> </ul>"},{"location":"#lab-resources","title":"Lab Resources","text":"<p>It is quite important to try all examples in the lecture notes. You have two options:</p> <ol> <li> <p>Use online compilers (Quick and easy):</p> <ul> <li>Online GDB</li> </ul> </li> <li> <p>Install C++ GNU toolchain.</p> <ul> <li>Install MinGW GNU C++ compiler (version &gt;= 9.2)</li> <li>Install VS Code Editor</li> </ul> </li> </ol>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>C203, C408</li> </ul>"},{"location":"#grading","title":"Grading","text":"Activity Weight Lab1 10%"},{"location":"#tentative-schedule","title":"Tentative Schedule","text":"Week # Lab # Topic Week 0 Lab 0 Installing C++ compiler Week 1 Lab 1"},{"location":"labs/lab01/","title":"Lab(1): Introduction","text":""},{"location":"labs/lab01/#fibonacci-series","title":"Fibonacci Series","text":"<p>Let us assume the following fibonacci series:</p> \\[ 1, 1, 2, 3, 5, 8, \\dots \\] <p>This series can be defined mathematically as follows:</p> \\[     fib(n) =  \\begin{cases}     1 &amp; n \\leq 1 \\\\     fib(n-1) + fib(n-2) &amp; n &gt; 1 \\end{cases} \\] <p>This implies that</p> <ol> <li>\\(fib(0) = 1\\)</li> <li>\\(fib(1) = 1\\)</li> <li>\\(fib(2) = fib(1) + fib(0) = 1 + 1 = 2\\)</li> <li>\\(fib(3) = fib(2) + fib(1) = 2 + 1 = 3\\)</li> <li>\\(fib(4) = fib(3) + fib(2) = 3 + 2 = 5\\)</li> <li>and so on.</li> </ol> <p>Let us implement the fibonacci series using a recursive function:</p> <pre><code>unsigned long long fib (unsigned int n)\n{\n    if (n &lt;= 1)\n        return 1;\n    else\n        return fib(n-1) + fib(n-2);\n}\n</code></pre> <p>The purpose of implementing fibonacci series recursively is that the running time is exponential. To see that, copy and run the following program:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nunsigned long long fib(unsigned int);\n\nint main()\n{\n    cout &lt;&lt; \"fib(30) = \" &lt;&lt; fib(30) &lt;&lt; endl;\n    cout &lt;&lt; \"fib(40) = \" &lt;&lt; fib(40) &lt;&lt; endl;\n    cout &lt;&lt; \"fib(45) = \" &lt;&lt; fib(45) &lt;&lt; endl;\n    cout &lt;&lt; \"fib(48) = \" &lt;&lt; fib(48) &lt;&lt; endl;\n\n    return 0;\n}\n\nunsigned long long fib(unsigned int n)\n{\n    if (n &lt;= 1)\n        return 1;\n    else\n        return fib(n-1) + fib(n-2);\n}\n</code></pre> <p>If you run the code, you should observe that <code>fib(30)</code> will be promptly printed out. <code>fib(40)</code> may take half second to be printed. <code>fib(45)</code> will take 5-6 seconds. But <code>fib(48)</code> will take significant amount of time almost 26 seconds in my computer.</p>"}]}